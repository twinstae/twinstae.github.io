import { j as element, y as text, z as space, k as claim_element, l as children, A as claim_text, B as claim_space, d as detach_dev, n as attr_dev, D as toggle_class, o as add_location, i as insert_hydration_dev, E as append_hydration_dev, Q as listen_dev, F as set_data_dev, g as dispatch_dev, v as validate_each_argument, H as noop, G as destroy_each, M as run_all, I as validate_store, J as component_subscribe, s as validate_slots, P as onMount, S as SvelteComponentDev, w as init, x as safe_not_equal } from '../index-328232cc.js';
import '../index-e9702746.js';
import { t as tag_list, s as selected_tag, a as tagStoreInit } from '../tag-eb30cbd7.js';

/* src/components/TagNav.svelte generated by Svelte v3.46.4 */
const file = "src/components/TagNav.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i][0];
	child_ctx[9] = list[i][1];
	return child_ctx;
}

// (34:2) {#each tag_count_list as [tag, count] }
function create_each_block(ctx) {
	let button;
	let t0;
	let t1_value = /*tag*/ ctx[8] + "";
	let t1;
	let t2;
	let t3_value = /*count*/ ctx[9] + "";
	let t3;
	let t4;
	let mounted;
	let dispose;

	function click_handler_2() {
		return /*click_handler_2*/ ctx[7](/*tag*/ ctx[8]);
	}

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("#");
			t1 = text(t1_value);
			t2 = space();
			t3 = text(t3_value);
			t4 = space();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "#");
			t1 = claim_text(button_nodes, t1_value);
			t2 = claim_space(button_nodes);
			t3 = claim_text(button_nodes, t3_value);
			t4 = claim_space(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "hashtag svelte-7eigsf");
			toggle_class(button, "selected", /*$selected_tag*/ ctx[1] == /*tag*/ ctx[8]);
			add_location(button, file, 34, 4, 893);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, t0);
			append_hydration_dev(button, t1);
			append_hydration_dev(button, t2);
			append_hydration_dev(button, t3);
			append_hydration_dev(button, t4);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*tag_count_list*/ 1 && t1_value !== (t1_value = /*tag*/ ctx[8] + "")) set_data_dev(t1, t1_value);
			if (dirty & /*tag_count_list*/ 1 && t3_value !== (t3_value = /*count*/ ctx[9] + "")) set_data_dev(t3, t3_value);

			if (dirty & /*$selected_tag, tag_count_list*/ 3) {
				toggle_class(button, "selected", /*$selected_tag*/ ctx[1] == /*tag*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(34:2) {#each tag_count_list as [tag, count] }",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let header;
	let t0;
	let t1;
	let button0;
	let t2;
	let t3;
	let button1;
	let t4;
	let t5;
	let mounted;
	let dispose;
	let each_value = /*tag_count_list*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			header = element("header");
			t0 = text("해시태그 목록");
			t1 = space();
			button0 = element("button");
			t2 = text("전체");
			t3 = space();
			button1 = element("button");
			t4 = text("작성 중🚧");
			t5 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			header = claim_element(div_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			t0 = claim_text(header_nodes, "해시태그 목록");
			header_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			button0 = claim_element(div_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t2 = claim_text(button0_nodes, "전체");
			button0_nodes.forEach(detach_dev);
			t3 = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			t4 = claim_text(button1_nodes, "작성 중🚧");
			button1_nodes.forEach(detach_dev);
			t5 = claim_space(div_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(header, "class", "svelte-7eigsf");
			add_location(header, file, 26, 2, 550);
			attr_dev(button0, "class", "hashtag svelte-7eigsf");
			toggle_class(button0, "selected", /*$selected_tag*/ ctx[1] == "");
			add_location(button0, file, 27, 2, 577);
			attr_dev(button1, "class", "hashtag svelte-7eigsf");
			toggle_class(button1, "selected", /*$selected_tag*/ ctx[1] == "작성 중");
			add_location(button1, file, 30, 2, 707);
			attr_dev(div, "id", "tag-nav");
			attr_dev(div, "class", "svelte-7eigsf");
			add_location(div, file, 25, 0, 529);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, header);
			append_hydration_dev(header, t0);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, button0);
			append_hydration_dev(button0, t2);
			append_hydration_dev(div, t3);
			append_hydration_dev(div, button1);
			append_hydration_dev(button1, t4);
			append_hydration_dev(div, t5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[5], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$selected_tag*/ 2) {
				toggle_class(button0, "selected", /*$selected_tag*/ ctx[1] == "");
			}

			if (dirty & /*$selected_tag*/ 2) {
				toggle_class(button1, "selected", /*$selected_tag*/ ctx[1] == "작성 중");
			}

			if (dirty & /*$selected_tag, tag_count_list, selected_tag*/ 3) {
				each_value = /*tag_count_list*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let tag_counter;
	let tag_count_list;
	let $tag_list;
	let $selected_tag;
	validate_store(tag_list, 'tag_list');
	component_subscribe($$self, tag_list, $$value => $$invalidate(4, $tag_list = $$value));
	validate_store(selected_tag, 'selected_tag');
	component_subscribe($$self, selected_tag, $$value => $$invalidate(1, $selected_tag = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TagNav', slots, []);
	let { blog_list } = $$props;

	onMount(() => {
		tagStoreInit(blog_list);
	});

	const writable_props = ['blog_list'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TagNav> was created with unknown prop '${key}'`);
	});

	const click_handler = function () {
		selected_tag.set("");
	};

	const click_handler_1 = function () {
		selected_tag.set("작성 중");
	};

	const click_handler_2 = function (tag) {
		selected_tag.set(tag);
	};

	$$self.$$set = $$props => {
		if ('blog_list' in $$props) $$invalidate(2, blog_list = $$props.blog_list);
	};

	$$self.$capture_state = () => ({
		onMount,
		tagStoreInit,
		tag_list,
		selected_tag,
		blog_list,
		tag_counter,
		tag_count_list,
		$tag_list,
		$selected_tag
	});

	$$self.$inject_state = $$props => {
		if ('blog_list' in $$props) $$invalidate(2, blog_list = $$props.blog_list);
		if ('tag_counter' in $$props) $$invalidate(3, tag_counter = $$props.tag_counter);
		if ('tag_count_list' in $$props) $$invalidate(0, tag_count_list = $$props.tag_count_list);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$tag_list*/ 16) {
			$: $$invalidate(3, tag_counter = $tag_list.reduce(
				(acc, tag) => {
					if (tag == "작성 중") {
						return acc;
					}

					if (!acc.has(tag)) {
						acc.set(tag, 0);
					}

					acc.set(tag, acc.get(tag) + 1);
					return acc;
				},
				new Map()
			));
		}

		if ($$self.$$.dirty & /*tag_counter*/ 8) {
			$: $$invalidate(0, tag_count_list = [...tag_counter.entries()].sort(([a, a_count], [b, b_count]) => b_count - a_count));
		}
	};

	return [
		tag_count_list,
		$selected_tag,
		blog_list,
		tag_counter,
		$tag_list,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class TagNav extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { blog_list: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TagNav",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*blog_list*/ ctx[2] === undefined && !('blog_list' in props)) {
			console.warn("<TagNav> was created without expected prop 'blog_list'");
		}
	}

	get blog_list() {
		throw new Error("<TagNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set blog_list(value) {
		throw new Error("<TagNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { TagNav as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFnTmF2LmZjZmU1OTgxLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UYWdOYXYuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgaW1wb3J0IHsgdGFnU3RvcmVJbml0LCB0YWdfbGlzdCwgc2VsZWN0ZWRfdGFnIH0gZnJvbSBcIi4uL3N0b3Jlcy90YWdcIjtcbiAgZXhwb3J0IGxldCBibG9nX2xpc3Q7XG5cbiAgb25Nb3VudCgoKT0+e1xuICAgIHRhZ1N0b3JlSW5pdChibG9nX2xpc3QpO1xuICB9KVxuXG4gICQ6IHRhZ19jb3VudGVyID0gJHRhZ19saXN0LnJlZHVjZSgoYWNjLCB0YWcpPT57XG4gICAgaWYgKHRhZz09XCLsnpHshLEg7KSRXCIpe1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICBpZiAoIWFjYy5oYXModGFnKSl7XG4gICAgICBhY2Muc2V0KHRhZywgMCk7XG4gICAgfVxuXG4gICAgYWNjLnNldCh0YWcsIGFjYy5nZXQodGFnKSArIDEpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIG5ldyBNYXAoKSlcblxuICAkOiB0YWdfY291bnRfbGlzdCA9IFsuLi50YWdfY291bnRlci5lbnRyaWVzKCldLnNvcnQoKFthLCBhX2NvdW50XSwgW2IsIGJfY291bnRdKT0+IGJfY291bnQgLSBhX2NvdW50KTtcbjwvc2NyaXB0PlxuPGRpdiBpZD1cInRhZy1uYXZcIj5cbiAgPGhlYWRlcj7tlbTsi5ztg5zqt7gg66qp66GdPC9oZWFkZXI+XG4gIDxidXR0b24gY2xhc3M9XCJoYXNodGFnXCIgY2xhc3M6c2VsZWN0ZWQ9eyRzZWxlY3RlZF90YWcgPT0gXCJcIn0gb246Y2xpY2s9e2Z1bmN0aW9uKCl7IHNlbGVjdGVkX3RhZy5zZXQoXCJcIik7IH19PlxuICAgIOyghOyytFxuICA8L2J1dHRvbj5cbiAgPGJ1dHRvbiBjbGFzcz1cImhhc2h0YWdcIiBjbGFzczpzZWxlY3RlZD17JHNlbGVjdGVkX3RhZyA9PSBcIuyekeyEsSDspJFcIn0gb246Y2xpY2s9e2Z1bmN0aW9uKCl7IHNlbGVjdGVkX3RhZy5zZXQoXCLsnpHshLEg7KSRXCIpOyB9fT5cbiAgICDsnpHshLEg7KSR8J+ap1xuICA8L2J1dHRvbj5cbiAgeyNlYWNoIHRhZ19jb3VudF9saXN0IGFzIFt0YWcsIGNvdW50XSB9XG4gICAgPGJ1dHRvbiBjbGFzcz1cImhhc2h0YWdcIiBjbGFzczpzZWxlY3RlZD17JHNlbGVjdGVkX3RhZyA9PSB0YWd9IG9uOmNsaWNrPXtmdW5jdGlvbigpeyBzZWxlY3RlZF90YWcuc2V0KHRhZyk7IH19PlxuICAgICAgI3t0YWd9IHtjb3VudH1cbiAgICA8L2J1dHRvbj5cbiAgey9lYWNofVxuPC9kaXY+XG5cblxuPHN0eWxlPlxuICBoZWFkZXIge1xuICAgIGNvbG9yOiB2YXIoLS1wcmltYXJ5KTtcbiAgICBmb250LXNpemU6IDEuMjVyZW07XG4gICAgbWFyZ2luOiAwLjI1cmVtO1xuICB9XG5cbiAgZGl2I3RhZy1uYXYge1xuICAgIGxpbmUtaGVpZ2h0OiAxMDAlO1xuICAgIHBhZGRpbmc6IC41cmVtO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLW11dGVkKTtcbiAgICBib3JkZXItcmFkaXVzOiAuNXJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgfVxuXG4gIC5zZWxlY3RlZCB7XG4gICAgYm9yZGVyOiAycHggc29saWQgb3JhbmdlO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFtQ1EsR0FBRyxDQUFBLENBQUEsQ0FBQSxHQUFBLEVBQUEsQ0FBQTs7OzBCQUFHLEdBQUssQ0FBQSxDQUFBLENBQUEsR0FBQSxFQUFBLENBQUE7Ozs7Ozs7Ozs7Ozs7YUFEOEYsR0FDMUcsQ0FBQSxDQUFBOzs7Ozs7Ozs7O2lDQUQwRyxHQUMx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

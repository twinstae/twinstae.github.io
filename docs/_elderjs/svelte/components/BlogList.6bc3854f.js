import { e as empty, c as create_component, a as claim_component, i as insert_hydration_dev, m as mount_component, t as transition_in, b as transition_out, d as detach_dev, f as destroy_component, g as dispatch_dev, v as validate_each_argument, h as validate_each_keys, j as element, k as claim_element, l as children, n as attr_dev, o as add_location, p as group_outros, u as update_keyed_each, q as outro_and_destroy_block, r as check_outros, s as validate_slots, S as SvelteComponentDev, w as init, x as safe_not_equal } from '../index-328232cc.js';
import BlogTeaser from './BlogTeaser.50e207e8.js';
import '../tag-eb30cbd7.js';

/* src/components/BlogList.svelte generated by Svelte v3.46.4 */
const file = "src/components/BlogList.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (9:2) {#each blog_list as blog (blog.frontmatter.title)}
function create_each_block(key_1, ctx) {
	let first;
	let blogteaser;
	let current;

	blogteaser = new BlogTeaser({
			props: { blog: /*blog*/ ctx[1] },
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(blogteaser.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(blogteaser.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, first, anchor);
			mount_component(blogteaser, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const blogteaser_changes = {};
			if (dirty & /*blog_list*/ 1) blogteaser_changes.blog = /*blog*/ ctx[1];
			blogteaser.$set(blogteaser_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blogteaser.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(blogteaser.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(blogteaser, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(9:2) {#each blog_list as blog (blog.frontmatter.title)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*blog_list*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*blog*/ ctx[1].frontmatter.title;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "entries svelte-3diyp8");
			add_location(ul, file, 7, 0, 94);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*blog_list*/ 1) {
				each_value = /*blog_list*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BlogList', slots, []);
	let { blog_list } = $$props;
	const writable_props = ['blog_list'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BlogList> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('blog_list' in $$props) $$invalidate(0, blog_list = $$props.blog_list);
	};

	$$self.$capture_state = () => ({ BlogTeaser, blog_list });

	$$self.$inject_state = $$props => {
		if ('blog_list' in $$props) $$invalidate(0, blog_list = $$props.blog_list);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [blog_list];
}

class BlogList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { blog_list: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BlogList",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*blog_list*/ ctx[0] === undefined && !('blog_list' in props)) {
			console.warn("<BlogList> was created without expected prop 'blog_list'");
		}
	}

	get blog_list() {
		throw new Error("<BlogList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set blog_list(value) {
		throw new Error("<BlogList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { BlogList as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmxvZ0xpc3QuNmJjMzg1NGYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0Jsb2dMaXN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgQmxvZ1RlYXNlciBmcm9tIFwiLi9CbG9nVGVhc2VyLnN2ZWx0ZVwiO1xuXG4gIGV4cG9ydCBsZXQgYmxvZ19saXN0O1xuPC9zY3JpcHQ+XG5cblxuPHVsIGNsYXNzPVwiZW50cmllc1wiPlxuICB7I2VhY2ggYmxvZ19saXN0IGFzIGJsb2cgKGJsb2cuZnJvbnRtYXR0ZXIudGl0bGUpfVxuICAgIDxCbG9nVGVhc2VyIHtibG9nfSAvPlxuICB7L2VhY2h9XG48L3VsPlxuXG5cbjxzdHlsZT5cbiAgLmVudHJpZXMge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7XG4gICAgbWFyZ2luOiAzcmVtIDA7XG4gIH1cblxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICAuZW50cmllcyB7XG4gICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyO1xuICAgICAgbWFyZ2luOiAzcmVtIDA7XG4gICAgfVxuICAgIDpnbG9iYWwoLmVudHJpZXMgLmVudHJ5KSB7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDFyZW07XG4gICAgfVxuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBUVMsR0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBOztpQ0FBVSxHQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQTs7O2dDQUE5QyxNQUFJLEVBQUEsQ0FBQSxJQUFBLENBQUEsRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FEUixvQkFJSSxDQUFBLE1BQUEsRUFBQSxFQUFBLEVBQUEsTUFBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7K0JBSEssR0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBOzs7Ozs7Ozs7OztrQ0FBZCxNQUFJLEVBQUEsQ0FBQSxJQUFBLENBQUEsRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BTEssU0FBUyxFQUFBLEdBQUEsT0FBQSxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
